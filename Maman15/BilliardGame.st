CircleMorph subclass: #BilliardBall	instanceVariableNames: 'velocity position number'	classVariableNames: ''	poolDictionaries: ''	category: 'BilliardGame'!!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:57'!drawOn: aCanvas    "Draw the ball with shading and highlights"    | center radius highlight |    center := self bounds center.    radius := self width // 2.        "Draw main ball circle"    aCanvas         fillOval: self bounds        color: self color.        "Add highlight effect"    highlight := (radius * 0.6) asInteger.    aCanvas         fillOval: (center - (highlight@highlight) extent: highlight@highlight)        color: (self color lighter lighter alpha: 0.5).        "Draw ball number with shadow"    number > 0 ifTrue: [        | numString font |        font := TextStyle default defaultFont.        numString := number asString.                "Draw shadow first"        aCanvas             drawString: numString            at: (center - (4@4))            font: font            color: (Color black alpha: 0.3).                    "Draw number"        aCanvas             drawString: numString            at: (center - (5@5))            font: font            color: Color white    ]! !!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 01:03'!initialize    super initialize.    self extent: 30@30.    number := 0.    self borderWidth: 1.    self borderColor: Color black! !!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 01:03'!number    "Return the ball's number"    ^number! !!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 21:26'!number: aNumber    number := aNumber.    self setColorForNumber: aNumber.    self changed. "Force redraw to show number"! !!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 20:46'!setColorForNumber: aNumber    aNumber = 0         ifTrue: [^self color: Color white].  "Cue ball"        "Standard colors for numbered balls"    self color: (self class ballColors at: aNumber)! !!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 20:46'!velocity    ^velocity! !!BilliardBall methodsFor: 'as yet unclassified' stamp: '8x8 2/23/2025 23:40'!velocity: aPoint    "Set the ball's velocity"    velocity := aPoint.    self changed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BilliardBall class	instanceVariableNames: ''!!BilliardBall class methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 21:04'!ballColors    "Returns a dictionary mapping ball numbers to their colors"    ^Dictionary new        at: 1 put: Color yellow;        at: 2 put: Color blue;        at: 3 put: Color red;        at: 4 put: Color magenta;  "Changed from purple"        at: 5 put: Color orange;        at: 6 put: Color green;        at: 7 put: (Color brown darker);        at: 8 put: Color black;        at: 9 put: Color yellow;        at: 10 put: Color blue;        at: 11 put: Color red;        at: 12 put: Color magenta;  "Changed from purple"        at: 13 put: Color orange;        at: 14 put: Color green;        at: 15 put: (Color brown darker);        yourself! !Morph subclass: #BilliardCue	instanceVariableNames: 'angle power startPoint endPoint isAiming whiteBall'	classVariableNames: ''	poolDictionaries: ''	category: 'BilliardGame'!!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:06'!angle    ^angle! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/20/2025 23:06'!drawDottedLineFrom: start to: end on: aCanvas color: aColor    "Draw a dotted line with small circles as dots"    | vector numDots spacing currentPoint |    vector := end - start.    numDots := 10.    spacing := vector / numDots.        0 to: numDots do: [:i |        currentPoint := start + (spacing * i).        aCanvas             fillOval: (currentPoint - (2@2) extent: 4@4)            color: aColor    ]! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/20/2025 23:06'!drawOn: aCanvas    | ballCenter start end aimEnd powerColor |    whiteBall ifNil: [^self].        ballCenter := whiteBall center.    start := ballCenter.    end := ballCenter + (Point r: 200 degrees: angle).        "Draw the cue stick"    aCanvas         line: start         to: end         width: 5        color: (Color brown darker).        "Draw aim line if we're aiming"    isAiming ifTrue: [        "Calculate power based on distance (max 100)"        power := ((startPoint x - endPoint x) squared +                  (startPoint y - endPoint y) squared) sqrt min: 100.                "Color gets more red as power increases"        powerColor := Color r: 1 g: (1 - (power/100)) b: 0 alpha: 0.5.                "Draw aim line in opposite direction of cue"        aimEnd := ballCenter + (Point r: (power * 2) degrees: angle + 180).                "Draw aim line as a series of small circles"        0 to: 10 do: [:i |            | pos |            pos := ballCenter + ((aimEnd - ballCenter) * (i/10)).            aCanvas                 fillOval: (pos - (2@2) extent: 4@4)                color: powerColor        ]    ]! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:01'!handlesMouseDown: evt    Transcript show: 'handlesMouseDown called'; cr.    ^true! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 01:06'!handlesMouseMove: evt    ^true! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/23/2025 23:50'!hide    "Hide the cue while ball is moving"    self visible: false.    self changed! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 01:05'!initialize    super initialize.    angle := 0.    power := 0.    isAiming := false.    self extent: 300@5.    self color: Color transparent.    self borderWidth: 0.    self setProperty: #morphicLayerNumber toValue: 1000! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:08'!mouseDown: evt    "Only allow aiming if balls aren't moving"    (self owner isMoving) ifTrue: [^self].        isAiming := true.    startPoint := evt cursorPoint.    endPoint := startPoint.    evt hand newMouseFocus: self.    self changed! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:13'!mouseMove: evt    "Only process movement if we're aiming and balls aren't moving"    (self owner isMoving) ifTrue: [^self].        isAiming ifTrue: [        whiteBall ifNotNil: [            | ballCenter newPoint |            ballCenter := whiteBall center.            newPoint := evt cursorPoint.            endPoint := newPoint.            angle := (newPoint - ballCenter) degrees.            self changed        ]    ]! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 02:12'!mouseUp: evt    "Only process shot if we're aiming and balls aren't moving"    (self owner isMoving) ifTrue: [^self].        isAiming ifTrue: [        | velocity |        "Adjusted power factor for better control"        velocity := Point r: (power * 0.2) degrees: angle + 180.        whiteBall velocity: velocity.        self hide.        self owner startSimulation    ].        isAiming := false.    evt hand newMouseFocus: nil.    self changed! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/20/2025 23:07'!power    "Return the current power (0-100)"    ^power! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:01'!rejectsEvent: evt    ^false! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/23/2025 23:50'!show    "Show the cue when ball stops"    self visible: true.    self changed! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:01'!wantsYellowButtonMenu    ^false! !!BilliardCue methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 01:05'!whiteBall: aBall    whiteBall := aBall! !Morph subclass: #BilliardTableMorph	instanceVariableNames: 'pockets tableFrame playingSurface balls isMoving pocketedBalls scoreDisplay'	classVariableNames: ''	poolDictionaries: ''	category: 'BilliardGame'!!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 21:22'!addBallNumber: number at: aPoint    | ball |    ball := BilliardBall new.    ball number: number.    ball position: aPoint - (15@15).    balls add: ball.    self addMorph: ball.! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 20:50'!addCueBallAt: aPoint    | cueBall |    cueBall := BilliardBall new.    cueBall number: 0.    cueBall position: aPoint - (15@15).    balls add: cueBall.    self addMorph: cueBall.! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:58'!addCushions    "Add cushion graphics"    | cushionColor |    cushionColor := Color brown darker darker.        #(top bottom left right) do: [:side |        | cushion |        cushion := RectangleMorph new.        cushion color: cushionColor.                side = #top ifTrue: [            cushion extent: (self width - 40)@10.            cushion position: self position + (20@10)].        side = #bottom ifTrue: [            cushion extent: (self width - 40)@10.            cushion position: self position + (20@(self height - 20))].        side = #left ifTrue: [            cushion extent: 10@(self height - 40).            cushion position: self position + (10@20)].        side = #right ifTrue: [            cushion extent: 10@(self height - 40).            cushion position: self position + (self width - 20@20)].                    self addMorph: cushion    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:33'!addPocketAt: aPoint    | pocket |    pocket := CircleMorph new.    pocket extent: 35@35.    pocket color: Color black.    pocket position: aPoint - (17@17).    pockets add: pocket.    self addMorph: pocket! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:17'!addPocketAt: aPoint size: extentPoint    | pocket |    pocket := CircleMorph new.    pocket extent: extentPoint.    pocket color: Color black.    pocket position: self position + aPoint - (extentPoint // 2).    pockets add: pocket.    self addMorph: pocket! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 02:03'!checkCollisionBetween: ball1 and: ball2    "Check if two balls are colliding"    | distance |    distance := (ball2 center - ball1 center) r.    ^distance < 30! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:14'!checkGameEnd    "Check if all numbered balls are pocketed"    (pocketedBalls size = 15) ifTrue: [        self resetGame.        self inform: 'Congratulations!! All balls pocketed. Starting new game.']! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 02:15'!createPlayingSurface    "Create a more realistic playing surface"    playingSurface := RectangleMorph new.    playingSurface extent: self extent - (40@40).        "Darker green with slight texture"    playingSurface color: (Color green darker darker).        "Add cushions"    self addCushions.        playingSurface borderWidth: 0.    self addMorph: playingSurface.    playingSurface position: self position + (20@20)! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:33'!createPockets    "Create pockets at the correct positions"    pockets := OrderedCollection new.        "Create corner pockets"    self addPocketAt: 25@25.                                     "Top Left"    self addPocketAt: (self width - 25)@25.                      "Top Right"    self addPocketAt: 25@(self height - 25).                     "Bottom Left"    self addPocketAt: (self width - 25)@(self height - 25).      "Bottom Right"        "Create middle pockets"    self addPocketAt: (self width // 2)@25.                      "Top Middle"    self addPocketAt: (self width // 2)@(self height - 25)       "Bottom Middle"! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 21:34'!createRackFormationAt: startPoint withSpacing: spacing    | rows xOffset |    "Define rows with proper ball order"    rows := #(        (1)             "Front (apex)"        (2 15)          "Second row"        (3 8 14)        "Third row"        (4 11 13 10)    "Fourth row"        (5 6 7 12 9)    "Back row"    ).        xOffset := 0.    rows withIndexDo: [:row :rowIndex |        | yOffset |        "Calculate y offset to center each row"        yOffset := (spacing * (row size - 1)) / 2.                row withIndexDo: [:ballNumber :colIndex |            | xPos yPos |            xPos := startPoint x + xOffset.  "Changed minus to plus"            yPos := startPoint y + yOffset - ((colIndex - 1) * spacing).                        self addBallNumber: ballNumber at: xPos@yPos        ].        xOffset := xOffset + (spacing * 0.866) "sin(60°) for equilateral triangle"    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:31'!drawOn: aCanvas    "Ensure clean drawing"    aCanvas fillRectangle: self bounds color: self color.    super drawOn: aCanvas! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 02:16'!handleBallCollisions    "Handle collisions between balls"    1 to: balls size do: [:i |        | ball1 |        ball1 := balls at: i.                i + 1 to: balls size do: [:j |            | ball2 |            ball2 := balls at: j.                        (self checkCollisionBetween: ball1 and: ball2)                ifTrue: [self resolveBallCollision: ball1 with: ball2]        ]    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 02:04'!handleWallCollisionsFor: ball at: newPos    "Handle wall collisions with cushion effect"    | bounced cushionEffect |    bounced := false.    cushionEffect := 0.7.  "More energy loss on wall collision"        "Left wall"    (newPos x < (self position x + 20)) ifTrue: [        ball position: (self position x + 20) @ ball position y.        ball velocity: (ball velocity x negated * cushionEffect @                       (ball velocity y * cushionEffect)).        bounced := true].            "Right wall"        (newPos x > (self position x + self width - 50)) ifTrue: [        ball position: (self position x + self width - 50) @ ball position y.        ball velocity: (ball velocity x negated * cushionEffect @                       (ball velocity y * cushionEffect)).        bounced := true].            "Top wall"    (newPos y < (self position y + 20)) ifTrue: [        ball position: ball position x @ (self position y + 20).        ball velocity: (ball velocity x * cushionEffect @                       (ball velocity y negated * cushionEffect)).        bounced := true].            "Bottom wall"    (newPos y > (self position y + self height - 50)) ifTrue: [        ball position: ball position x @ (self position y + self height - 50).        ball velocity: (ball velocity x * cushionEffect @                       (ball velocity y negated * cushionEffect)).        bounced := true].            ^bounced! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:43'!handlesMouseDown: evt    ^true! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:08'!initialize    super initialize.        "Initialize collections"    balls := OrderedCollection new.    pockets := OrderedCollection new.    pocketedBalls := OrderedCollection new.    isMoving := false.        "Set up basic dimensions"    self extent: 800@400.        "Create the playing surface"    playingSurface := RectangleMorph new.    playingSurface extent: self extent - (40@40).    playingSurface color: (Color green darker darker).    playingSurface borderWidth: 0.        "Create the frame"    tableFrame := BorderedMorph new.    tableFrame extent: self extent.    tableFrame borderWidth: 20.    tableFrame borderColor: (Color brown darker).    tableFrame color: Color transparent.        "Create score display"    scoreDisplay := StringMorph new.    scoreDisplay contents: 'Pocketed Balls: 0'.    scoreDisplay color: Color white.        self clipSubmorphs: false.        "Add morphs in correct order"    self addMorph: playingSurface.    self addMorph: tableFrame.    self addMorph: scoreDisplay.        "Position morphs"    playingSurface position: self position + (20@20).    scoreDisplay position: self position + (20@(self height + 5)).        self createPockets.    self initializeBalls.    self initializeCue.    self color: Color transparent! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/18/2025 21:21'!initializeBalls    | rackPosition ballDiameter spacing |    balls := OrderedCollection new.    ballDiameter := 30.    spacing := ballDiameter + 2.        "Position for the rack (about 1/4 from the right side)"    rackPosition := self position +         ((self width * 0.75)@(self height // 2)) asPoint.        "Create and position cue ball (on the left side)"    self addCueBallAt: (self position +         ((self width * 0.25)@(self height // 2)) asPoint).        "Create and position the other 15 balls in a triangle rack"    self createRackFormationAt: rackPosition        withSpacing: spacing.! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 01:07'!initializeCue    | cue whiteBall |    cue := BilliardCue new.        "Get the white ball"    balls ifNotEmpty: [        whiteBall := balls first.        cue whiteBall: whiteBall.        "Position cue's morph to cover the entire table for better event handling"        cue extent: self extent.        cue position: self position.        self addMorph: cue    ].    ^cue! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:33'!isBallInPocket: ball    "Check if ball is in any pocket"    ^pockets anySatisfy: [:pocket |        | distance |        distance := (pocket center - ball center) r.        distance < 20  "Adjusted detection radius"    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:03'!isMoving    ^isMoving! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:41'!mouseDown: evt    "Only start dragging if explicitly requested"    evt redButtonPressed ifTrue: [        evt hand waitForClicksOrDrag: self event: evt.        evt wasHandled: true    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:44'!pocketedBallCount    "Return number of pocketed balls"    ^pocketedBalls size! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:14'!resetGame    "Reset the entire game state"    | whiteBall |        "Store white ball if exists"    whiteBall := balls detect: [:ball | ball number = 0] ifNone: [nil].        "Remove all existing balls"    balls do: [:ball | ball delete].    balls removeAll.    pocketedBalls removeAll.        "Reset score display"    scoreDisplay contents: 'Pocketed Balls: 0'.        "Reinitialize balls"    self initializeBalls.        "Update cue with new white ball"    self submorphs         detect: [:m | m isKindOf: BilliardCue]         ifFound: [:cue |             cue whiteBall: (balls detect: [:b | b number = 0])]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:32'!resolveBallCollision: ball1 with: ball2    "Resolve collision between two balls using elastic collision"    | normal v1 v2 newV1 newV2 overlap correction |        "Get velocities, use 0@0 if nil"    v1 := ball1 velocity ifNil: [0@0].    v2 := ball2 velocity ifNil: [0@0].        "Calculate normal vector between balls"    normal := (ball2 center - ball1 center) normalized.        "Calculate new velocities after collision"    newV1 := v1 + (normal * ((v2 - v1 dotProduct: normal) * 0.8)).    newV2 := v2 + (normal * ((v1 - v2 dotProduct: normal) * 0.8)).        "Update ball velocities"    ball1 velocity: newV1.    ball2 velocity: newV2.        "Separate balls to prevent sticking"    overlap := 30 - (ball2 center - ball1 center) r.    overlap > 0 ifTrue: [        correction := normal * (overlap / 2).        ball1 position: ball1 position - correction.        ball2 position: ball2 position + correction    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:43'!respawnWhiteBall    "Place the white ball back at its initial position"    | whiteBall initialPosition |    initialPosition := self position + ((self width * 0.25)@(self height // 2)) asPoint.        whiteBall := BilliardBall new.    whiteBall number: 0.    whiteBall position: initialPosition - (15@15).    balls addFirst: whiteBall.  "Add at start to maintain as first ball"    self addMorph: whiteBall.        "Update cue with new white ball"    self submorphs         detect: [:m | m isKindOf: BilliardCue]         ifFound: [:cue | cue whiteBall: whiteBall]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/23/2025 23:50'!showCue    "Find and show the cue"    self submorphs         detect: [:m | m isKindOf: BilliardCue]         ifFound: [:cue |             cue show.            cue whiteBall: balls first.  "Reconnect to white ball"            self changed        ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 00:03'!startSimulation    "Start the ball movement simulation"    isMoving := true.    self startStepping.    self step! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 02:18'!step    "Update ball positions each step"    | whiteBallPocketed ballsToRemove needsWhiteBallRespawn |    whiteBallPocketed := false.    needsWhiteBallRespawn := false.    ballsToRemove := OrderedCollection new.        "Check if white ball exists"    (balls noneSatisfy: [:b | b number = 0]) ifTrue: [        needsWhiteBallRespawn := true].        "Update positions and check wall collisions"    balls do: [:ball |        ball velocity ifNotNil: [            | newPos |            newPos := ball position + ball velocity.                        "Check pocket collisions first"            (self isBallInPocket: ball)                 ifTrue: [                    ball number = 0                        ifTrue: [needsWhiteBallRespawn := true]                        ifFalse: [                            pocketedBalls add: ball].                    ballsToRemove add: ball.                    scoreDisplay contents: 'Pocketed Balls: ', pocketedBalls size asString]                ifFalse: [                    "Only handle wall collisions if not pocketed"                    self handleWallCollisionsFor: ball at: newPos.                    ball position: ball position + ball velocity.                    ball velocity: ball velocity * 0.99                ]        ]    ].        "Remove pocketed balls"    ballsToRemove do: [:ball |        balls remove: ball.        ball delete].        "Handle ball-to-ball collisions"    self handleBallCollisions.        "Check if all remaining balls have stopped"    (balls allSatisfy: [:ball |         ball velocity isNil or: [ball velocity r < 0.1]    ]) ifTrue: [        balls do: [:ball | ball velocity: nil].        self stopStepping.        isMoving := false.                "Check if game is complete"        self checkGameEnd.                "Respawn white ball if it was pocketed"        needsWhiteBallRespawn ifTrue: [self respawnWhiteBall].                self showCue    ] ifFalse: [        "If balls are still moving and white ball is missing, respawn it"        needsWhiteBallRespawn ifTrue: [            self respawnWhiteBall.            needsWhiteBallRespawn := false]    ]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/23/2025 23:45'!stepTime    "Return the desired time between steps in milliseconds"    ^16! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/23/2025 23:47'!stopSimulation    "Stop the simulation and show the cue again"    self stopStepping.    self submorphs         detect: [:m | m isKindOf: BilliardCue]         ifFound: [:cue | cue show]! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/24/2025 01:06'!updateScoreDisplay    "Update the score display with current count"    scoreDisplay contents: 'Pocketed Balls: ', pocketedBalls size asString! !!BilliardTableMorph methodsFor: 'as yet unclassified' stamp: '8x8 2/19/2025 00:35'!wantsYellowButtonMenu    "Disable context menu for table"    ^false! !