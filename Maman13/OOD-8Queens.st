ImageMorph subclass: #BoardTile	instanceVariableNames: 'tileHeight tileWidth blockedCell safeColor nextTile neighbours results imagePath arrowOverlay isBlocked'	classVariableNames: ''	poolDictionaries: ''	category: 'OOD-8Queens'!!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:18'!"Display a border around the tile to highlight it, typically used to indicate a solution."displayBorder    self borderWidth: 1.    self borderColor: safeColor.! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:13'!"Display the image representing an empty tile. This method should be implemented by subclasses."displayEmptyTile    ^ self subclassResponsibility! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:13'!"Display the image representing a queen on the tile. This method should be implemented by subclasses."displayQueen    ^ self subclassResponsibility! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:58'!handlesMouseDown: anEvent    "Indicate that this morph handles mouse down events."    ^ true! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:56'!initialize: anImagePath showResults: showResultsFlag     "Initialize the BoardTile with specified image path and results flag."	super initialize.		"Set tile dimensions."	tileWidth :=50.	tileHeight :=50.		 "Define colors for different states."	blockedCell := Color red.	safeColor := Color gray.	"Initial tile state is unblocked."	isBlocked := false.		"Set the size of the tile."	self width: tileWidth.	self height: tileHeight.		"Enable resizing behaviors."	self vResizing: #spaceFill.	self hResizing: #spaceFill.		 "Set up a click event handler for the tile."	"self on: #click send: #tileClicked to: self."		(showResultsFlag notNil) ifTrue: [results := showResultsFlag].	"Store the image path for loading tile images."	imagePath := anImagePath.	^ self "Return the initialized instance."! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:22'!"Return the blocked state of the tile."isBlocked    ^ isBlocked! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 15:30'!mouseDown: anEvent    "Handle the mouse down event. If it's a right-click, toggle the tile's blocked state."        anEvent yellowButtonPressed ifTrue: [        self tileClicked.        anEvent wasHandled: true.    ].! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:21'!"Retrieve the next unblocked tile in the sequence."nextTile    (nextTile isBlocked)        ifTrue: [^ nextTile nextTile] "If the next tile is blocked, recursively get the next one."        ifFalse: [^ nextTile]. "Return the next tile if it's unblocked."! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:18'!"Remove the border around the tile."removeBorder    self borderWidth: 0.! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:03'!"Set the neighboring tiles in all eight directions."setNeighborsUp: upTile upLeft: upLeftTile upRight: upRightTile right: rightTile left: leftTile down: downTile downLeft: downLeftTile downRight: downRightTile    "Set the neighboring tiles in all eight directions."    neighbours := Dictionary newFrom: {        #up -> upTile.        #upLeft -> upLeftTile.        #upRight -> upRightTile.        #right -> rightTile.        #left -> leftTile.        #down -> downTile.        #downLeft -> downLeftTile.        #downRight -> downRightTile.    }.! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:20'!"Set the next tile in the sequence for traversal."setNextTile: aTile    nextTile := aTile! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 16:39'!"Visualize a threat line from this tile to another tile, typically used to show conflicts between queens."showThreatLineTo: anotherTile    "Create a line morph representing the threat."    arrowOverlay := (LineMorph from: self center to: anotherTile center color: Color blue width: 2) makeForwardArrow.    "Display the arrow in the world."    arrowOverlay openInWorld.    "If results are not being shown, pause briefly to display the arrow."    results ifFalse: [        World doOneCycle.        (Delay forSeconds: 0.5) wait.    ].    arrowOverlay delete.    ^ self! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:12'!tileClicked     "Handle the click event on the tile. Toggle the blocked state and update the appearance accordingly."    isBlocked := isBlocked not.    "Update the border color based on the new state."    isBlocked        ifTrue: [ self borderColor: blockedCell ]        ifFalse: [ self borderColor: safeColor ].   "Set the border width to make the block visible."    self borderWidth: 1.! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:23'!"Return the height of the tile."tileHeight    ^ tileHeight! !!BoardTile methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:23'!"Return the width of the tile."tileWidth    ^ tileWidth! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BoardTile class	instanceVariableNames: 'tileWidth tileHeight'!!BoardTile class methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 21:30'!"Factory method to create a BoardTile instance at a given position. Determines whether to create a DarkTile or LightTile based on the position."createAtRow: row column: column totalRows: totalRows imagePath: imagePath showResults: showResultsFlag    | index |     "Calculate a unique index for position-based tile coloring."    index := (row * totalRows) + column.     "Determine the tile type based on position for a checkerboard pattern."    (((row rem: 2) = 0 and: [ (index rem: 2) = 0 ])         or: [ (row rem: 2) = 1 and: [ (index rem: 2) = 1 ] ])        ifTrue: [ ^ DarkTile new initialize: imagePath showResults: showResultsFlag ]   "Create a DarkTile for dark squares."        ifFalse: [ ^ LightTile new initialize: imagePath showResults: showResultsFlag ].  "Create a LightTile for light squares."! !BorderedMorph subclass: #ChessBoardGUI	instanceVariableNames: 'numberOfRows tileMatrix boardWidth boardHeight imagePath'	classVariableNames: ''	poolDictionaries: ''	category: 'OOD-8Queens'!!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:17'!"Remove borders from all tiles to reset the board."clearBoard    1 to: numberOfRows do: [:row|        1 to: numberOfRows do: [:column |            (tileMatrix at: row at: column) removeBorder.        ]    ].! !!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 15:32'!contextMenu: aMenuEvent    "Prevent the default context menu from appearing on right-click."    ^ nil! !!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:14'!"Create a BoardTile instance at the specified row and column."createTileAtRow: row atColumn: column showResults: showResultsFlag    ^ BoardTile createAtRow: row column: column totalRows: numberOfRows imagePath: imagePath showResults: showResultsFlag.! !!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:17'!"Highlight the tiles corresponding to the solution by displaying borders around them."displaySolution: rowList    1 to: rowList size do: [:index |	  "Get the tile at the position specified in the solution list and display a border."        (tileMatrix at: (rowList at: index) at: index) displayBorder.    ].     "Refresh the world to show updates."    World doOneCycle.    "Wait for a few seconds to display the solution."    (Delay forSeconds: 5) wait.    "Clear the board after displaying the solution."    self clearBoard.! !!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:14'!"Retrieve the tile at the specified row and column from the tile matrix."getTileAtRow: row column: column    ^ tileMatrix at: row at: column.! !!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 15:48'!"Initialize the ChessBoardGUI with the given board size and results flag."initialize: size showResults: showResultsFlag    | defaultTile newTile rowMorph tileWidth tileHeight |    super initialize.     "Set the path to the images used for the tiles."    imagePath := 'c:\\Maman13\\gameImages\\'.    "Set the number of rows (and columns) for the square board."    numberOfRows := size.    "Create a default tile to determine tile dimensions."    defaultTile := self createTileAtRow: 1 atColumn: 1 showResults: showResultsFlag.    tileWidth := defaultTile tileWidth.    tileHeight := defaultTile tileHeight.    "Calculate the total board dimensions."    boardWidth := numberOfRows * tileWidth.    boardHeight := numberOfRows * tileHeight.    "Initialize the matrix to hold all the tiles."    tileMatrix := Matrix new: numberOfRows.    "Set the position and size of the board."    self position: 10@10.    self extent: boardWidth @ boardHeight.    "Configure the layout of the board."    self layoutPolicy: TableLayout new.    self listDirection: #bottomToTop. "Tiles are added from bottom to top."    self listCentering: #topLeft.    self wrapCentering: #center.    self vResizing: #spaceFill.    self hResizing: #spaceFill.    self color: Color black. "Set the background color of the board."    self openInWorld.        "Create and arrange the tiles on the board."    1 to: numberOfRows do: [ :row |        rowMorph := Morph new.        rowMorph layoutPolicy: TableLayout new.        rowMorph listDirection: #rightToLeft. "Tiles in a row are added from right to left."        rowMorph extent: boardWidth @ tileHeight.        rowMorph listCentering: #topLeft.        rowMorph wrapCentering: #center.        1 to: numberOfRows do: [ :column |	      "Create a tile at the specified row and column."            newTile := self createTileAtRow: row atColumn: column showResults: showResultsFlag.             "Store the tile in the matrix."            tileMatrix at: row at: column put: newTile.            "Add the tile to the row morph."            rowMorph addMorph: newTile.        ].        self addMorph: rowMorph.    ].    "Link tiles to their neighbors and set up the next tile references."    self linkTiles.! !!ChessBoardGUI methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:16'!"Link each tile to its neighboring tiles and set up the next tile for traversal."linkTiles    1 to: numberOfRows do: [:row |        1 to: numberOfRows do: [:column |	      "Check if the tile is a border tile or a middle tile."            ((row = numberOfRows or: [column = numberOfRows]) or: [row = 1 or: [column = 1]])            ifFalse: [                "Middle tiles (not on the border). Set their neighbors."                (tileMatrix at: row at: column)                     setNeighborsUp: (tileMatrix at: row - 1 at: column)                    upLeft: (tileMatrix at: row - 1 at: column - 1)                    upRight: (tileMatrix at: row - 1 at: column + 1)                    right: (tileMatrix at: row at: column + 1)                    left: (tileMatrix at: row at: column - 1)                    down: (tileMatrix at: row + 1 at: column)                    downLeft: (tileMatrix at: row + 1 at: column - 1)                    downRight: (tileMatrix at: row + 1 at: column + 1).                 "Set the next tile in the column."                (tileMatrix at: row at: column)                     setNextTile: (tileMatrix at: row + 1 at: column).            ]            ifTrue: [                "Tiles on the border"                                 "Set the next tile in the column, wrapping around if necessary."                (row = numberOfRows)                    ifTrue: [                        (tileMatrix at: row at: column)                             setNextTile: (tileMatrix at: 1 at: column)                    ]                    ifFalse: [                        (tileMatrix at: row at: column)                             setNextTile: (tileMatrix at: row + 1 at: column)                    ].                                 "Set neighbors based on the position of the tile."                "Top-left corner"                ((row = 1) and: [column = 1])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: nil                            upLeft: nil                            upRight: nil                            right: (tileMatrix at: row at: column + 1)                            left: nil                            down: (tileMatrix at: row + 1 at: column)                            downLeft: nil                            downRight: (tileMatrix at: row + 1 at: column + 1)                    ].                                "Top-right corner"                ((row = 1) and: [column = numberOfRows])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: nil                            upLeft: nil                            upRight: nil                            right: nil                            left: (tileMatrix at: row at: column - 1)                            down: (tileMatrix at: row + 1 at: column)                            downLeft: (tileMatrix at: row + 1 at: column - 1)                            downRight: nil                    ].                                "Bottom-left corner"                ((row = numberOfRows) and: [column = 1])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: (tileMatrix at: row - 1 at: column)                            upLeft: nil                            upRight: (tileMatrix at: row - 1 at: column + 1)                            right: (tileMatrix at: row at: column + 1)                            left: nil                            down: nil                            downLeft: nil                            downRight: nil                    ].                                "Bottom-right corner"                ((row = numberOfRows) and: [column = numberOfRows])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: (tileMatrix at: row - 1 at: column)                            upLeft: (tileMatrix at: row - 1 at: column - 1)                            upRight: nil                            right: nil                            left: (tileMatrix at: row at: column - 1)                            down: nil                            downLeft: nil                            downRight: nil                    ].                                "Top edge (excluding corners)"                ((row = 1) and: [(column ~= 1) and: [column ~= numberOfRows]])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: nil                            upLeft: nil                            upRight: nil                            right: (tileMatrix at: row at: column + 1)                            left: (tileMatrix at: row at: column - 1)                            down: (tileMatrix at: row + 1 at: column)                            downLeft: (tileMatrix at: row + 1 at: column - 1)                            downRight: (tileMatrix at: row + 1 at: column + 1)                    ].                                "Bottom edge (excluding corners)"                ((row = numberOfRows) and: [(column ~= 1) and: [column ~= numberOfRows]])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: (tileMatrix at: row - 1 at: column)                            upLeft: (tileMatrix at: row - 1 at: column - 1)                            upRight: (tileMatrix at: row - 1 at: column + 1)                            right: (tileMatrix at: row at: column + 1)                            left: (tileMatrix at: row at: column - 1)                            down: nil                            downLeft: nil                            downRight: nil                    ].                                "Left edge (excluding corners)"                (((row ~= 1) and: [row ~= numberOfRows]) and: [column = 1])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: (tileMatrix at: row - 1 at: column)                            upLeft: nil                            upRight: (tileMatrix at: row - 1 at: column + 1)                            right: (tileMatrix at: row at: column + 1)                            left: nil                            down: (tileMatrix at: row + 1 at: column)                            downLeft: nil                            downRight: (tileMatrix at: row + 1 at: column + 1)                    ].                                "Right edge (excluding corners)"                (((row ~= 1) and: [row ~= numberOfRows]) and: [column = numberOfRows])                    ifTrue: [                        (tileMatrix at: row at: column)                             setNeighborsUp: (tileMatrix at: row - 1 at: column)                            upLeft: (tileMatrix at: row - 1 at: column - 1)                            upRight: nil                            right: nil                            left: (tileMatrix at: row at: column - 1)                            down: (tileMatrix at: row + 1 at: column)                            downLeft: (tileMatrix at: row + 1 at: column - 1)                            downRight: nil                    ].            ].        ].    ].! !BoardTile subclass: #DarkTile	instanceVariableNames: 'emptyImagePath queenImagePath'	classVariableNames: ''	poolDictionaries: ''	category: 'OOD-8Queens'!!DarkTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:07'!"Display the image representing an empty dark tile."displayEmptyTile    self image: (ImageReadWriter formFromFileNamed: emptyImagePath).! !!DarkTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:07'!"Display the image representing a queen on a dark tile."displayQueen    self image: (ImageReadWriter formFromFileNamed: queenImagePath).! !!DarkTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 16:01'!"Initialize the DarkTile with the specified image path and results flag."initialize: anImagePath showResults: showResultsFlag    super initialize: anImagePath showResults: showResultsFlag.    "Image for an empty dark tile."    emptyImagePath := imagePath , 'darkTile.bmp'.    "Image for a dark tile with a queen."    queenImagePath := imagePath , 'darkQueen.bmp'.    self displayEmptyTile.    ^ self! !BoardTile subclass: #LightTile	instanceVariableNames: 'emptyImagePath queenImagePath'	classVariableNames: ''	poolDictionaries: ''	category: 'OOD-8Queens'!!LightTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:08'!"Display the image representing an empty light tile."displayEmptyTile    self image: (ImageReadWriter formFromFileNamed: emptyImagePath).! !!LightTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:08'!"Display the image representing a queen on a light tile."displayQueen    self image: (ImageReadWriter formFromFileNamed: queenImagePath).! !!LightTile methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 16:01'!"Initialize the LightTile with the specified image path and results flag."initialize: anImagePath showResults: showResultsFlag    super initialize: anImagePath showResults: showResultsFlag.    "Image for an empty light tile."    emptyImagePath := imagePath , 'lightTile.bmp'.     "Image for a light tile with a queen."    queenImagePath := imagePath , 'lightQueen.bmp'.    self displayEmptyTile.    ^ self! !Object subclass: #QueenSolver	instanceVariableNames: 'currentRow column previousQueen tile lastQueen chessBoardGUI'	classVariableNames: ''	poolDictionaries: ''	category: 'OOD-8Queens'!!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:27'!"Advance the queen to the next row or backtrack if necessary."advance   "Check if the queen has reached the last row."    currentRow = 8 ifTrue: [	 "Attempt to advance the previous solver (backtracking)."        previousQueen nextSolution ifFalse: [^ false].        currentRow := 0.    ].    "Increment the current row to move down."    currentRow := currentRow + 1.    self removeQueenFromTile. "Remove the queen from the current tile."    self moveToNextTile. "Move to the next tile and display the queen."    self displayQueenOnTile.    ^ true. "Indicate that the advance was successful."! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:28'!"Determine if this queen can attack another queen at the specified row and column."canAttack: aQueen inRow: aRow inColumn: aColumn    | columnDifference |    "Calculate the difference in columns between this queen and the other."    columnDifference := aColumn - column.    "Check for attacking positions (same row, same diagonal)."    ((currentRow = aRow)        or: [currentRow + columnDifference = aRow]        or: [currentRow - columnDifference = aRow])        ifTrue: [	      "Visualize the threat line between the queens."            tile showThreatLineTo: aQueen getTile.            ^ true "Queen can attack."        ].    "Delegate the check to the previous solver."    ^ previousQueen canAttack: aQueen inRow: aRow inColumn: aColumn.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:25'!"Display the queen image on the associated tile."displayQueenOnTile    tile displayQueen.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:33'!"Display the solution by highlighting this queen's tile and invoking display on previous solvers."displaySolution    tile displayBorder.    previousQueen isTerminator ifFalse: [        previousQueen displaySolution    ].! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:29'!"Find the first solution starting from this queen solver."firstSolution   "Invoke firstSolution on the previous solver."    previousQueen firstSolution.    currentRow := 1. "Initialize currentRow to 1."    ^ self nextOptionAttackRow. "Find the next row where the queen does not attack others."! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:33'!"Retrieve the tile associated with this queen solver."getTile    ^ tile.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 15:46'!"Initialize the queen solver with the given board size and results flag."initialize: size showResults: showResultsFlag   "Create a new chess board GUI."    chessBoardGUI := ChessBoardGUI new.    chessBoardGUI initialize: size showResults: showResultsFlag.    "Initialize the last solver as a terminator."    lastQueen := QueenTerminator new.    "Set up the chain of queen solvers for each column."    1 to: size do: [:i |        lastQueen := QueenSolver new            setColumn: i previousQueen: lastQueen;            setTile: (chessBoardGUI getTileAtRow: 1 column: i);            displayQueenOnTile.    ].! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:35'!"Check if this solver is the terminator."isTerminator    ^ false.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:25'!"Move the queen solver to the next unblocked tile in the same column."moveToNextTile    tile := tile nextTile.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:30'!"Find the next row where the queen does not conflict with other queens."nextOptionAttackRow    [previousQueen canAttack: self inRow: currentRow inColumn: column]        whileTrue: [self advance ifFalse: [^ false]].  "If conflict exists, attempt to advance."    ^ true. "Found a valid position without conflicts."! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:30'!"Find the next possible solution by advancing the queen and checking for conflicts."nextSolution    ^ self advance and: [self nextOptionAttackRow].! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:25'!"Remove the queen image from the associated tile, displaying it as empty."removeQueenFromTile    tile displayEmptyTile.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:30'!"Collect the current solution as a sequence of row numbers."result    ^ previousQueen result add: currentRow; yourself.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:24'!"Set the column position and previous solver (neighbor) for this queen solver."setColumn: col previousQueen: queen    column := col.    previousQueen:= queen.    ^ self "Return self to allow method chaining."! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:24'!"Set the tile (board position) associated with this queen solver."setTile: aTile    tile := aTile.! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 15:49'!solve    "Initiate the solving process and display all solutions."    | solution |    "Clear the transcript for clean output."    Transcript clear.    "Attempt to find the first solution."    lastQueen firstSolution        ifTrue: [            "Retrieve and display the solution."            solution := lastQueen result.            Transcript show: solution printString; cr.            lastQueen displaySolution.            "Iterate to find and display all other solutions."            [ lastQueen nextSolution ] whileTrue: [                solution := lastQueen result.                Transcript show: solution printString; cr.                lastQueen displaySolution.            ].            Transcript show: 'Game Over!!!!'; cr.        ]        ifFalse: [            Transcript show: 'Game failed - solution not found.'; cr.        ].! !!QueenSolver methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 15:47'!"Start the queen solver with default settings."start    self initialize: 8 showResults: false. "Initialize with an 8x8 board and results flag."        "Begin solving the puzzle in a separate process."    self solve.! !QueenSolver subclass: #QueenTerminator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOD-8Queens'!!QueenTerminator methodsFor: 'as yet unclassified' stamp: '8x8 1/11/2025 20:33'!canAttack: aQueen inRow: aRow inColumn: aColumn    ^ false.! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:38'!"Base case for firstSolution. Always returns true."firstSolution    ^ true.! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:38'!"Indicates that this is the terminator of the queen solver chain."isTerminator    ^ true.! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:38'!"Base case for nextSolution. Always returns false."nextSolution    ^ false.! !!QueenTerminator methodsFor: 'as yet unclassified' stamp: '8x8 1/12/2025 14:38'!"Base case for collecting results. Returns a new empty collection."result    ^ OrderedCollection new.! !